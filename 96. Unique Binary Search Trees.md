### 题意

Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

给定一个n，求由1...n组成的结构不同的二叉查找树的个数。

### 分析

#### 卡特兰数 (Catalan number)

Catalan数的定义令h(1)=1，Catalan数满足递归式：h(n) = h(1)*h(n-1) + h(2)*h(n-2) + ... + h(n-1)h(1)，n>=2该递推关系的解为：h(n) = C(2n,n)/(n+1)，n=1,2,3,...（其中C(2n-2,n-1)表示2n-2个中取n-1个的组合数），解也可为h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)。

**应用：**

递推等式的应用：
*括号化：*矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种)

*出栈次序：*一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?
常规分析
首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)\*f(k-1)种，求和便是Catalan递归式。

非常规分析
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。
在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。
不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。
反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。
因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。
显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n)。

*凸多边形三角划分*
*括号匹配*

在本题中，要求1到n这些书能够生成的二叉查找树的数目。
一般来说，我们可以先从根节点开始选择。根节点的选择有n种，当根节点被确定之后，由于二叉查找树的性质，左右子树中数值的范围和数目也就被确定了。可得如下的式子：
h(n) = h(n - 1) + h(1) * h(n - 2) + ... + h(n - 2) * h(1) + h(n - 1)。
这其实就是卡特兰数。运用递归的方法很容易就能求出来：h[0] = 1; h[1] = 1;
## 代码
```
class Solution {
public:
    int numTrees(int n) {
        int i, j;
        vector<int> f(n + 1);
        f[0] = 1;
        f[1] = 1;
        for (i = 2; i <= n; i++){
            f[i] = 0;
            for (j = 0; j < i; j++)
                f[i] += f[j] * f [i - 1 - j];
        }
        return f[n];
    }
};
```